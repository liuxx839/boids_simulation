<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Boids终极生态模型：繁衍与生命周期</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            cursor: pointer;
            
            /* --- 新增/修改: 优化移动端点击效果 --- */
            -webkit-tap-highlight-color: transparent; /* 核心：移除移动端点击时的默认高亮效果 */
            user-select: none; /* 推荐：防止用户误触时选中页面元素 */
            outline: none; /* 推荐：移除元素获取焦点时的默认轮廓 */
        }
        canvas { display: block; }
        .info { position: absolute; top: 10px; left: 10px; padding: 12px; background-color: rgba(0,0,0,0.7); border-radius: 5px; font-size: 14px; pointer-events: none; min-width: 230px; }
        .info span { display: inline-block; width: 12px; height: 12px; border-radius: 50%; vertical-align: middle; margin-right: 8px; }
        .info div { margin-bottom: 6px; }
        .info hr { border: 0; border-top: 1px solid #444; margin: 8px 0; }
        .info .highlight { color: #58a6ff; }
        .info .danger { color: #f07167; }
        .info .brave { color: #a374ff; }
        .info strong { float: right; color: #fff; }
    </style>
</head>
<body>
    <div class="info">
        <div><span style="background-color: #4f8a8b;"></span>群组 A (普通)<strong id="percentA">100%</strong></div>
        <div><span style="background-color: #ffcb74;"></span>群组 B (高速)<strong id="percentB">100%</strong></div>
        <div class="brave"><span style="background-color: #a374ff;"></span>群组 C (会反击)<strong id="percentC">100%</strong></div>
        <div class="danger"><span style="background-color: #f07167;"></span>捕食者</div>
        <hr>
        <div class="highlight"><strong>点击屏幕可引导Boids</strong></div>
        <div>Boids现在需要寻找食物生存</div>
        <div>它们会躲进半透明的安全区</div>
    </div>
    <canvas id="boidsCanvas"></canvas>

<script>
// --- 向量类 ---
class Vector {
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(s) { this.x *= s; this.y *= s; return this; }
    div(s) { if (s !== 0) { this.x /= s; this.y /= s; } return this; }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { const m = this.mag(); if (m > 0) this.div(m); return this; }
    limit(max) { if (this.mag() > max) this.normalize().mult(max); return this; }
    static dist(v1, v2) { const dx = v1.x - v2.x; const dy = v1.y - v2.y; return Math.sqrt(dx * dx + dy * dy); }
    static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
}

// --- 通用智能体基类 ---
class Agent {
    constructor(x, y, config) { this.position = new Vector(x, y); this.velocity = new Vector(Math.random()*2-1, Math.random()*2-1); this.acceleration = new Vector(); this.config = config; this.velocity.limit(this.config.maxSpeed); this.isAlive = true; this.deathTime = null; }
    update() { if (!this.isAlive) return; this.velocity.add(this.acceleration); this.velocity.limit(this.config.maxSpeed); this.position.add(this.velocity); this.acceleration.mult(0); }
    edges() { if (!this.isAlive) return; if (this.position.x > window.innerWidth) this.position.x = 0; else if (this.position.x < 0) this.position.x = window.innerWidth; if (this.position.y > window.innerHeight) this.position.y = 0; else if (this.position.y < 0) this.position.y = window.innerHeight; }
}

// --- Boid 类 ---
class Boid extends Agent {
    constructor(x, y, config) {
        super(x, y, config);
        this.birthingUrge = 0;
        this.awarenessEndTime = 0;
        // --- 新增: 能量机制 ---
        this.energy = 100; // 初始能量
        this.maxEnergy = 150; // 最大能量
    }
    
    showAwarenessIndicator(duration = 1500) { this.awarenessEndTime = Date.now() + duration; }

    // --- 修改: applyBehaviors 方法，增加了对食物和安全区的反应 ---
    applyBehaviors(allBoids, ownFlock, predators, obstacles, target, foodSources, safeZones) {
        if (!this.isAlive) return;

        // 基础行为
        const avoid = this.avoid(obstacles).mult(this.config.avoidWeight);
        const sep = this.separation(allBoids).mult(this.config.separationWeight);
        const ali = this.alignment(ownFlock).mult(this.config.alignmentWeight);
        const coh = this.cohesion(ownFlock).mult(this.config.cohesionWeight);
        
        this.acceleration.add(avoid); this.acceleration.add(sep); this.acceleration.add(ali); this.acceleration.add(coh);

        // --- 新增: 策略决策 ---
        let isThreatened = this.isThreatened(predators); // 判断是否受威胁
        
        if (isThreatened) {
            // 受威胁时，优先逃往最近的安全区
            const fleeToSafeZone = this.seekClosest(safeZones).mult(this.config.seekWeight * 1.5); // 逃往安全区的欲望更强
            this.acceleration.add(fleeToSafeZone);
        } else if (this.energy < 70) {
            // 不受威胁且饥饿时，寻找食物
            const seekFood = this.seekClosest(foodSources, true).mult(this.config.seekWeight);
            this.acceleration.add(seekFood);
        }

        // 捕食者规避/反击行为
        if (this.config.canMob) {
            let localMatesCount = 0;
            for (let other of ownFlock) { if (other !== this && Vector.dist(this.position, other.position) < this.config.perceptionRadius) { localMatesCount++; } }
            if (localMatesCount > this.config.mobThreshold) { this.acceleration.add(this.mob(predators).mult(this.config.mobWeight)); } else { this.acceleration.add(this.flee(predators).mult(this.config.fleeWeight)); }
        } else { this.acceleration.add(this.flee(predators).mult(this.config.fleeWeight)); }
        
        // 鼠标引导行为
        if (target && Vector.dist(this.position, target) < MOUSE_INFLUENCE_RADIUS) { this.acceleration.add(this.seek(target).mult(this.config.seekWeight)); }
    }
    
    // --- 新增: 判断是否受威胁 ---
    isThreatened(predators) {
        for (let p of predators) {
            if (Vector.dist(this.position, p.position) < this.config.fleeRadius) {
                return true;
            }
        }
        return false;
    }

    // --- 新增: 寻找最近的目标 (可用于食物、安全区等) ---
    seekClosest(targets, eat = false) {
        let closestDist = Infinity;
        let closestTarget = null;
        for (let target of targets) {
            let d = Vector.dist(this.position, target.position);
            if (d < closestDist) {
                closestDist = d;
                closestTarget = target;
            }
        }
        
        if (closestTarget) {
            if (eat && closestDist < 10) { // 如果是食物并且足够近
                this.energy = Math.min(this.maxEnergy, this.energy + closestTarget.energyValue);
                closestTarget.isEaten = true; // 标记食物被吃掉
            }
            return this.seek(closestTarget.position);
        }
        return new Vector();
    }

    // --- 修改: Boid的update方法以包含能量消耗 ---
    update() {
        if (!this.isAlive) return;
        super.update(); // 调用父类的update
        this.energy -= 0.08; // 持续消耗能量
        if (this.energy <= 0) {
            this.die(); // 能量耗尽则死亡
        }
    }

    // --- 新增: Boid的死亡方法 ---
    die() {
        this.isAlive = false;
        this.deathTime = Date.now();
        tombstones.push(this);
    }

    handleReproduction(ownFlock) {
        // --- 修改: 繁殖需要消耗能量 ---
        if (!this.config.canReproduce || this.energy < 120) return null; // 能量充足才能繁殖
        
        let closeMates = 0;
        for (let other of ownFlock) { if (other !== this && Vector.dist(this.position, other.position) < this.config.reproductionRadius) { closeMates++; } }
        
        if (closeMates >= this.config.reproductionThreshold) { this.birthingUrge += 0.5; } else { this.birthingUrge = Math.max(0, this.birthingUrge - 1); }
        
        if (this.birthingUrge >= this.config.reproductionUrgeMax) {
            this.birthingUrge = 0;
            if (Math.random() < this.config.reproductionChance) {
                this.energy -= 50; // 繁殖消耗大量能量
                return new Boid(this.position.x, this.position.y, this.config);
            }
        }
        return null;
    }

    mob(predators) { let s = new Vector(); let t=0; for (let p of predators) { let d=Vector.dist(this.position,p.position); if (d < this.config.fleeRadius) { s.add(Vector.sub(p.position,this.position)); t++; }} if (t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce*1.5); } return s; }
    flee(threats) { let s = new Vector(); let t=0; for (let p of threats) { let d=Vector.dist(this.position,p.position); if (d < this.config.fleeRadius) { s.add(Vector.sub(this.position,p.position)); t++; }} if (t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce*2); } return s; }
    avoid(obstacles) { let s = new Vector(); for (let o of obstacles) { let d=Vector.dist(this.position,o.position); if (d < this.config.avoidRadius) { let diff = Vector.sub(this.position,o.position); diff.div(d*d); s.add(diff);}} if (s.mag()>0) { s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce*2); } return s; }
    seek(target) { let d = Vector.sub(target, this.position); d.normalize().mult(this.config.maxSpeed); return Vector.sub(d, this.velocity).limit(this.config.maxForce*1.5); }
    separation(allBoids) { let s = new Vector(); let t=0; for (let o of allBoids) { let d=Vector.dist(this.position,o.position); if (o!==this && d < this.config.separationRadius) { let diff=Vector.sub(this.position,o.position); diff.div(d*d); s.add(diff); t++;}} if(t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce); } return s; }
    alignment(ownFlock) { let s = new Vector(); let t=0; for (let o of ownFlock) { if(o!==this) { s.add(o.velocity); t++; }} if (t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce); } return s; }
    cohesion(ownFlock) { let s = new Vector(); let t=0; for (let o of ownFlock) { if(o!==this) { s.add(o.position); t++; }} if (t>0) { s.div(t); s.sub(this.position); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce); } return s; }
    
    draw(ctx) {
        if (this.isAlive && this.awarenessEndTime > Date.now()) {
            const timeLeft = this.awarenessEndTime - Date.now();
            const fadeDuration = 500;
            let opacity = 1;
            if (timeLeft < fadeDuration) { opacity = timeLeft / fadeDuration; }
            ctx.save(); ctx.translate(this.position.x, this.position.y); ctx.font = 'bold 14px sans-serif'; ctx.fillStyle = `rgba(255, 255, 100, ${opacity})`; ctx.textAlign = 'center'; ctx.fillText('!', 0, -12); ctx.restore();
        }

        if (!this.isAlive) { this.drawTombstone(ctx); return; }

        // --- 新增: 根据能量值改变Boid的透明度 ---
        const alpha = 0.3 + (this.energy / this.maxEnergy) * 0.7;

        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(Math.atan2(this.velocity.y, this.velocity.x));
        ctx.beginPath();
        ctx.moveTo(10, 0); ctx.lineTo(-5, -5); ctx.lineTo(-5, 5); ctx.closePath();
        // 将颜色转换为rgba以应用透明度
        let hex = this.config.color.replace('#', '');
        let r = parseInt(hex.substring(0,2), 16);
        let g = parseInt(hex.substring(2,4), 16);
        let b = parseInt(hex.substring(4,6), 16);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
        ctx.fill();
        ctx.restore();
    }

    drawTombstone(ctx) { ctx.save(); ctx.translate(this.position.x, this.position.y); ctx.strokeStyle = '#666'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-6, -6); ctx.lineTo(6, 6); ctx.moveTo(6, -6); ctx.lineTo(-6, 6); ctx.stroke(); ctx.restore(); }
}

// --- Predator 类 ---
class Predator extends Agent {
    constructor(x, y, config) { super(x, y, config); }
    
    // --- 修改: 捕食者行为，增加对安全区的躲避 ---
    applyBehaviors(allBoids, otherPredators, safeZones) {
        if (!this.isAlive) return;
        let attackers = [];
        for (let boid of allBoids) { if (Vector.dist(this.position, boid.position) < this.config.perceptionRadius) { let toPredator = Vector.sub(this.position, boid.position).normalize(); let boidDir = boid.velocity.mag() > 0 ? new Vector(boid.velocity.x, boid.velocity.y).normalize() : new Vector(); if ((toPredator.x * boidDir.x + toPredator.y * boidDir.y) > 0.8) { attackers.push(boid); } } }
        
        // 躲避安全区
        const avoidSafeZones = this.avoid(safeZones).mult(this.config.fleeWeight * 2);
        this.acceleration.add(avoidSafeZones);

        if (attackers.length > this.config.intimidationThreshold) {
            this.acceleration.add(this.flee(attackers).mult(this.config.fleeWeight));
        } else {
            this.acceleration.add(this.seek(allBoids).mult(this.config.seekWeight));
        }
        this.acceleration.add(this.separation(otherPredators).mult(this.config.separationWeight));
    }

    flee(threats) { let s = new Vector(); let t=0; for (let p of threats) { s.add(Vector.sub(this.position,p.position)); t++; } if (t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce*2); } return s; }
    seek(prey) { let closestDist = Infinity; let closestPrey = null; for (let b of prey) { if (b.isAlive && Vector.dist(this.position, b.position) < this.config.perceptionRadius) { let d = Vector.dist(this.position, b.position); if (d < closestDist) { closestDist = d; closestPrey = b; } } } if (closestPrey) { let d = Vector.sub(closestPrey.position, this.position); d.normalize().mult(this.config.maxSpeed); return Vector.sub(d, this.velocity).limit(this.config.maxForce); } return new Vector(); }
    separation(otherPredators) { let s = new Vector(); let t=0; for (let o of otherPredators) { let d=Vector.dist(this.position,o.position); if (o!==this && d < this.config.separationRadius) { let diff=Vector.sub(this.position,o.position); diff.div(d); s.add(diff); t++;}} if(t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce); } return s; }
    
    // --- 新增: 捕食者也需要躲避机制，这里复用Boid的 ---
    avoid(obstacles) { let s = new Vector(); for (let o of obstacles) { let d=Vector.dist(this.position,o.position); if (d < (o.radius || this.config.perceptionRadius / 2)) { let diff = Vector.sub(this.position,o.position); diff.div(d*d); s.add(diff);}} if (s.mag()>0) { s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce*3); } return s; }

    draw(ctx) { if(!this.isAlive) return; ctx.save(); ctx.translate(this.position.x, this.position.y); ctx.rotate(Math.atan2(this.velocity.y, this.velocity.x)); ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-7, -7); ctx.lineTo(-7, 7); ctx.closePath(); ctx.fillStyle = this.config.color; ctx.fill(); ctx.restore(); }
}

// --- 主程序 ---
const canvas = document.getElementById('boidsCanvas'), ctx = canvas.getContext('2d');
canvas.width = window.innerWidth; canvas.height = window.innerHeight;
let mouseTarget = null, targetTimeout = null;
const MOUSE_INFLUENCE_RADIUS = 250;
let clickWaves = [];

// --- 音频对象 ---
const soundA = new Audio('sound/a.mp3');
const soundB = new Audio('sound/b.mp3');
const soundC = new Audio('sound/c.mp3');
const sounds = [soundA, soundB, soundC];
sounds.forEach(sound => sound.volume = 0);

// --- 音量控制参数 ---
const MIN_GLOBAL_VOLUME = 0.15;
const MAX_GLOBAL_VOLUME = 1.0;
const BOIDS_FOR_MAX_VOLUME = 30;

// --- 配置区域 ---
const reproductionConfig = { canReproduce: true, reproductionRadius: 20, reproductionThreshold: 3, reproductionUrgeMax: 100, reproductionChance: 0.30 };
const flockA_Config = { color: '#4f8a8b', maxSpeed: 3.5, maxForce: 0.05, perceptionRadius: 50, separationRadius: 25, fleeRadius: 100, avoidRadius: 40, cohesionWeight: 1.0, alignmentWeight: 1.0, separationWeight: 1.5, fleeWeight: 2.5, seekWeight: 1.2, avoidWeight: 3.0, canMob: false, ...reproductionConfig };
const flockB_Config = { color: '#ffcb74', maxSpeed: 4.0, maxForce: 0.07, perceptionRadius: 60, separationRadius: 30, fleeRadius: 120, avoidRadius: 50, cohesionWeight: 0.8, alignmentWeight: 1.2, separationWeight: 1.3, fleeWeight: 2.0, seekWeight: 1.0, avoidWeight: 2.8, canMob: false, ...reproductionConfig };
const flockC_Config = { color: '#a374ff', maxSpeed: 3.8, maxForce: 0.06, perceptionRadius: 70, separationRadius: 28, fleeRadius: 110, avoidRadius: 45, cohesionWeight: 1.2, alignmentWeight: 0.8, separationWeight: 1.4, fleeWeight: 1.8, seekWeight: 1.1, avoidWeight: 2.9, canMob: true, mobThreshold: 5, mobWeight: 2.5, ...reproductionConfig };
const predatorConfig = { color: '#f07167', maxSpeed: 4.5, maxForce: 0.12, perceptionRadius: 200, separationRadius: 50, killRadius: 8, seekWeight: 1.8, separationWeight: 2.0, intimidationThreshold: 6, fleeWeight: 3.0 };

// --- 初始化 ---
const NUM_BOIDS_PER_FLOCK = 70;
let flockA = [], flockB = [], flockC = [], allBoids = [], predators = [], tombstones = [];
// --- 新增: 食物和安全区数组 ---
let foodSources = [];
let safeZones = [];
let initialCountA = 0, initialCountB = 0, initialCountC = 0;
const w = () => canvas.width, h = () => canvas.height;
const percentAEl = document.getElementById('percentA'), percentBEl = document.getElementById('percentB'), percentCEl = document.getElementById('percentC');

function initialize() {
    flockA = []; flockB = []; flockC = []; allBoids = []; predators = []; tombstones = [];
    foodSources = []; safeZones = []; // 重置

    for (let i = 0; i < NUM_BOIDS_PER_FLOCK; i++) { const b = new Boid(Math.random()*w(), Math.random()*h(), flockA_Config); flockA.push(b); allBoids.push(b); }
    for (let i = 0; i < NUM_BOIDS_PER_FLOCK; i++) { const b = new Boid(Math.random()*w(), Math.random()*h(), flockB_Config); flockB.push(b); allBoids.push(b); }
    for (let i = 0; i < NUM_BOIDS_PER_FLOCK; i++) { const b = new Boid(Math.random()*w(), Math.random()*h(), flockC_Config); flockC.push(b); allBoids.push(b); }
    for (let i = 0; i < 4; i++) { predators.push(new Predator(Math.random()*w(), Math.random()*h(), predatorConfig)); }
    
    // --- 新增: 初始化安全区 ---
    safeZones.push({ position: new Vector(w() * 0.2, h() * 0.5), radius: 80 });
    safeZones.push({ position: new Vector(w() * 0.8, h() * 0.5), radius: 80 });

    initialCountA = flockA.length; initialCountB = flockB.length; initialCountC = flockC.length;
}

// --- 新增: 生成食物的函数 ---
function spawnFood() {
    if (foodSources.length < 50 && Math.random() < 0.1) {
        foodSources.push({
            position: new Vector(Math.random() * w(), Math.random() * h()),
            energyValue: 30,
            isEaten: false
        });
    }
    foodSources = foodSources.filter(f => !f.isEaten);
}

// --- 动画循环 ---
function animate() {
    ctx.fillStyle = 'rgba(13, 17, 23, 0.25)'; ctx.fillRect(0, 0, w(), h());
    
    const now = Date.now();
    for (let i = clickWaves.length - 1; i >= 0; i--) {
        const wave = clickWaves[i];
        const age = now - wave.startTime;
        if (age > wave.duration) {
            clickWaves.splice(i, 1);
            continue;
        }
        const progress = age / wave.duration;
        const currentRadius = wave.maxRadius * progress;
        const opacity = 1 - progress;
        
        ctx.beginPath();
        ctx.arc(wave.position.x, wave.position.y, currentRadius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(88, 166, 255, ${opacity})`;
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    // --- 新增: 绘制安全区 ---
    safeZones.forEach(zone => {
        ctx.beginPath();
        ctx.arc(zone.position.x, zone.position.y, zone.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(79, 138, 139, 0.1)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(79, 138, 139, 0.4)';
        ctx.stroke();
    });

    // --- 新增: 生成并绘制食物 ---
    spawnFood();
    foodSources.forEach(food => {
        ctx.beginPath();
        ctx.arc(food.position.x, food.position.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#76c893';
        ctx.fill();
    });

    let newborns = [];
    allBoids.forEach(boid => {
        let ownFlock = (boid.config.color === flockA_Config.color) ? flockA : (boid.config.color === flockB_Config.color) ? flockB : flockC;
        // --- 修改: 传入食物和安全区信息 ---
        boid.applyBehaviors(allBoids, ownFlock, predators, tombstones, mouseTarget, foodSources, safeZones);
        boid.update();
        boid.edges();
        boid.draw(ctx);
        const newborn = boid.handleReproduction(ownFlock);
        if (newborn) { newborns.push(newborn); }
    });
    
    // 将因饥饿死亡的boid移出主列表
    for (let i = allBoids.length - 1; i >= 0; i--) {
        if (!allBoids[i].isAlive) {
            allBoids.splice(i, 1);
        }
    }

    newborns.forEach(nb => {
        allBoids.push(nb);
        if (nb.config.color === flockA_Config.color) { flockA.push(nb); initialCountA++; }
        else if (nb.config.color === flockB_Config.color) { flockB.push(nb); initialCountB++; }
        else { flockC.push(nb); initialCountC++; }
    });

    predators.forEach(predator => {
        // --- 修改: 传入安全区信息 ---
        predator.applyBehaviors(allBoids, predators, safeZones);
        predator.update(); predator.edges(); predator.draw(ctx);
        for (let i = allBoids.length - 1; i >= 0; i--) {
            const boid = allBoids[i];
            if (boid.isAlive && Vector.dist(predator.position, boid.position) < predator.config.killRadius) {
                boid.die(); // 使用die方法来处理死亡
                allBoids.splice(i, 1);
            }
        }
    });
    
    flockA = flockA.filter(b => b.isAlive); flockB = flockB.filter(b => b.isAlive); flockC = flockC.filter(b => b.isAlive);
    tombstones.forEach(t => t.draw(ctx));
    tombstones = tombstones.filter(t => Date.now() - t.deathTime < 3000);

    if (initialCountA > 0) percentAEl.innerText = `${Math.round((flockA.length / NUM_BOIDS_PER_FLOCK) * 100)}%`;
    if (initialCountB > 0) percentBEl.innerText = `${Math.round((flockB.length / NUM_BOIDS_PER_FLOCK) * 100)}%`;
    if (initialCountC > 0) percentCEl.innerText = `${Math.round((flockC.length / NUM_BOIDS_PER_FLOCK) * 100)}%`;

    requestAnimationFrame(animate);
}

// --- 事件监听器 ---
canvas.addEventListener('mousedown', e => { 
    mouseTarget = new Vector(e.clientX, e.clientY); 
    if(targetTimeout) clearTimeout(targetTimeout); 
    targetTimeout = setTimeout(()=> {mouseTarget = null;}, 5000); 

    clickWaves.push({
        position: new Vector(e.clientX, e.clientY),
        startTime: Date.now(),
        duration: 800,
        maxRadius: 60,
    });
    
    let awareCounts = { a: 0, b: 0, c: 0 };
    
    allBoids.forEach(boid => {
        if (boid.isAlive && Vector.dist(boid.position, mouseTarget) < MOUSE_INFLUENCE_RADIUS) {
            boid.showAwarenessIndicator();
            if (boid.config.color === flockA_Config.color) awareCounts.a++;
            else if (boid.config.color === flockB_Config.color) awareCounts.b++;
            else awareCounts.c++;
        }
    });

    const totalAware = awareCounts.a + awareCounts.b + awareCounts.c;

    if (totalAware > 0) {
        const volumeScale = Math.min(1.0, totalAware / BOIDS_FOR_MAX_VOLUME);
        const masterVolume = MIN_GLOBAL_VOLUME + volumeScale * (MAX_GLOBAL_VOLUME - MIN_GLOBAL_VOLUME);

        const finalVolumeA = masterVolume * (awareCounts.a / totalAware);
        const finalVolumeB = masterVolume * (awareCounts.b / totalAware);
        const finalVolumeC = masterVolume * (awareCounts.c / totalAware);

        const playSound = (audio, volume) => {
            if (volume > 0.01) {
                audio.volume = volume;
                audio.currentTime = 0;
                audio.play().catch(error => console.error("Audio playback failed:", error));
            }
        };

        playSound(soundA, finalVolumeA);
        playSound(soundB, finalVolumeB);
        playSound(soundC, finalVolumeC);
    }
});
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; initialize(); });

// 启动
initialize();
animate();
</script>
</body>
</html>
