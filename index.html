<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Boids终极生态模型：繁衍、生命周期与环境灾害</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            cursor: pointer;
            
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            outline: none;
        }
        canvas { display: block; }
        .info { position: absolute; top: 10px; left: 10px; padding: 12px; background-color: rgba(0,0,0,0.7); border-radius: 5px; font-size: 14px; pointer-events: none; min-width: 230px; }
        .info span { display: inline-block; width: 12px; height: 12px; border-radius: 50%; vertical-align: middle; margin-right: 8px; }
        .info div { margin-bottom: 6px; }
        .info hr { border: 0; border-top: 1px solid #444; margin: 8px 0; }
        .info .highlight { color: #58a6ff; }
        .info .danger { color: #f07167; }
        .info .brave { color: #a374ff; }
        .info strong { float: right; color: #fff; }
    </style>
</head>
<body>
    <div class="info">
        <div><span style="background-color: #4f8a8b;"></span>群组 A (普通)<strong id="percentA">100%</strong></div>
        <div><span style="background-color: #ffcb74;"></span>群组 B (高速)<strong id="percentB">100%</strong></div>
        <div class="brave"><span style="background-color: #a374ff;"></span>群组 C (会反击)<strong id="percentC">100%</strong></div>
        <div class="danger"><span style="background-color: #f07167;"></span>捕食者</div>
        <hr>
        <div class="highlight"><strong>点击屏幕可引导Boids</strong></div>
        <div>群体在密集时有机会繁衍</div>
        <div>墓碑障碍物会在3秒后消失</div>
    </div>
    <canvas id="boidsCanvas"></canvas>

<script>
// --- 图像加载 ---
const imageA = new Image(); imageA.src = 'image/a.png';
const imageB = new Image(); imageB.src = 'image/b.png';
const imageC = new Image(); imageC.src = 'image/c.png';
const imagePredator = new Image(); imagePredator.src = 'image/predators.png';
const imageBackground = new Image(); imageBackground.src = 'image/background.jpg';

// --- 向量类 ---
class Vector {
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(s) { this.x *= s; this.y *= s; return this; }
    div(s) { if (s !== 0) { this.x /= s; this.y /= s; } return this; }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { const m = this.mag(); if (m > 0) this.div(m); return this; }
    limit(max) { if (this.mag() > max) this.normalize().mult(max); return this; }
    clone() { return new Vector(this.x, this.y); }
    static dist(v1, v2) { const dx = v1.x - v2.x; const dy = v1.y - v2.y; return Math.sqrt(dx * dx + dy * dy); }
    static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
    static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
}

// --- 通用智能体基类 ---
class Agent {
    constructor(x, y, config) { this.position = new Vector(x, y); this.velocity = new Vector(Math.random()*2-1, Math.random()*2-1); this.acceleration = new Vector(); this.config = config; this.velocity.limit(this.config.maxSpeed); this.isAlive = true; this.deathTime = null; }
    update() { if (!this.isAlive) return; this.velocity.add(this.acceleration); this.velocity.limit(this.config.maxSpeed); this.position.add(this.velocity); this.acceleration.mult(0); }
    edges() { if (!this.isAlive) return; if (this.position.x > window.innerWidth) this.position.x = 0; else if (this.position.x < 0) this.position.x = window.innerWidth; if (this.position.y > window.innerHeight) this.position.y = 0; else if (this.position.y < 0) this.position.y = window.innerHeight; }
    
    applyWhirlpoolForce(whirlpools) {
        let force = new Vector();
        for (const w of whirlpools) {
            const currentRadius = w.baseRadius * w.lifeCycleProgress;
            const dist = Vector.dist(this.position, w.position);

            if (dist > 0 && dist < currentRadius) {
                const currentStrength = w.baseStrength * w.lifeCycleProgress;
                
                const pull = Vector.sub(w.position, this.position);
                const pullMagnitude = currentStrength * (1 - dist / currentRadius);
                pull.normalize().mult(pullMagnitude);

                const rotation = new Vector(-pull.y, pull.x);
                const rotationMagnitude = currentStrength * 1.5;
                rotation.normalize().mult(rotationMagnitude);

                force.add(pull).add(rotation);
            }
        }
        this.acceleration.add(force);
    }
}

// --- Boid 类 ---
class Boid extends Agent {
    constructor(x, y, config) { super(x, y, config); this.birthingUrge = 0; this.awarenessEndTime = 0; }
    showAwarenessIndicator(duration = 1500) { this.awarenessEndTime = Date.now() + duration; }
    applyBehaviors(allBoids, ownFlock, predators, obstacles, target, whirlpools, volcanoes) {
        if (!this.isAlive) return;
        const allObstacles = [...obstacles, ...volcanoes];
        const avoid = this.avoid(allObstacles).mult(this.config.avoidWeight);
        const sep = this.separation(allBoids).mult(this.config.separationWeight);
        const ali = this.alignment(ownFlock).mult(this.config.alignmentWeight);
        const coh = this.cohesion(ownFlock).mult(this.config.cohesionWeight);
        this.acceleration.add(avoid).add(sep).add(ali).add(coh);
        if (this.config.canMob) {
            let localMatesCount = 0;
            for (let other of ownFlock) { if (other !== this && Vector.dist(this.position, other.position) < this.config.perceptionRadius) { localMatesCount++; } }
            if (localMatesCount > this.config.mobThreshold) { this.acceleration.add(this.mob(predators).mult(this.config.mobWeight)); } else { this.acceleration.add(this.flee(predators).mult(this.config.fleeWeight)); }
        } else { this.acceleration.add(this.flee(predators).mult(this.config.fleeWeight)); }
        if (target && Vector.dist(this.position, target) < MOUSE_INFLUENCE_RADIUS) { this.acceleration.add(this.seek(target).mult(this.config.seekWeight)); }
        this.applyWhirlpoolForce(whirlpools);
    }
    handleReproduction(ownFlock) {
        if (!this.config.canReproduce) return null;
        let closeMates = 0;
        for (let other of ownFlock) { if (other !== this && Vector.dist(this.position, other.position) < this.config.reproductionRadius) { closeMates++; } }
        if (closeMates >= this.config.reproductionThreshold) { this.birthingUrge += 0.5; } else { this.birthingUrge = Math.max(0, this.birthingUrge - 1); }
        if (this.birthingUrge >= this.config.reproductionUrgeMax) { this.birthingUrge = 0; if (Math.random() < this.config.reproductionChance) { return new Boid(this.position.x, this.position.y, this.config); } }
        return null;
    }
    mob(predators) { let s = new Vector(); let t=0; for (let p of predators) { let d=Vector.dist(this.position,p.position); if (d < this.config.fleeRadius) { s.add(Vector.sub(p.position,this.position)); t++; }} if (t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce*1.5); } return s; }
    flee(threats) { let s = new Vector(); let t=0; for (let p of threats) { let d=Vector.dist(this.position,p.position); if (d < this.config.fleeRadius) { s.add(Vector.sub(this.position,p.position)); t++; }} if (t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce*2); } return s; }
    
    avoid(obstacles) {
        let steering = new Vector();
        for (let o of obstacles) {
            // 如果障碍物有致命半径（如火山），就用它来计算规避；否则用Boid自己的规避半径
            // 添加一个小的安全边际(15)，这样它们会在刚好进入危险区之前开始躲避
            const dangerRadius = (o.lethalRadius || 0) > 0 ? o.lethalRadius + 15 : this.config.avoidRadius;
            const d = Vector.dist(this.position, o.position);

            if (d > 0 && d < dangerRadius) {
                let diff = Vector.sub(this.position, o.position);
                // 距离越近，推力越强
                diff.div(d * d); 
                steering.add(diff);
            }
        }

        if (steering.mag() > 0) {
            steering.normalize();
            steering.mult(this.config.maxSpeed);
            steering.sub(this.velocity);
            steering.limit(this.config.maxForce * 4.5); // 稍微增强规避的力量
        }
        return steering;
    }

    seek(target) { let d = Vector.sub(target, this.position); d.normalize().mult(this.config.maxSpeed); return Vector.sub(d, this.velocity).limit(this.config.maxForce*1.5); }
    separation(allBoids) { let s = new Vector(); let t=0; for (let o of allBoids) { let d=Vector.dist(this.position,o.position); if (o!==this && d < this.config.separationRadius) { let diff=Vector.sub(this.position,o.position); diff.div(d*d); s.add(diff); t++;}} if(t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce); } return s; }
    alignment(ownFlock) { let s = new Vector(); let t=0; for (let o of ownFlock) { if(o!==this) { s.add(o.velocity); t++; }} if (t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce); } return s; }
    cohesion(ownFlock) { let s = new Vector(); let t=0; for (let o of ownFlock) { if(o!==this) { s.add(o.position); t++; }} if (t>0) { s.div(t); s.sub(this.position); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce); } return s; }
    draw(ctx) {
        if (this.isAlive && this.awarenessEndTime > Date.now()) { const timeLeft = this.awarenessEndTime - Date.now(), fadeDuration = 500; let opacity = (timeLeft < fadeDuration) ? (timeLeft / fadeDuration) : 1; ctx.save(); ctx.translate(this.position.x, this.position.y); ctx.font = 'bold 14px sans-serif'; ctx.fillStyle = `rgba(255, 255, 100, ${opacity})`; ctx.textAlign = 'center'; ctx.fillText('!', 0, -12); ctx.restore(); }
        if (!this.isAlive) { this.drawTombstone(ctx); return; }
        
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(Math.atan2(this.velocity.y, this.velocity.x));

        if (this.config.image && this.config.image.complete && this.config.image.naturalWidth !== 0) {
            const imgWidth = 22;
            const imgHeight = 22;
            ctx.drawImage(this.config.image, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
        } else {
            ctx.beginPath();
            ctx.moveTo(10, 0);
            ctx.lineTo(-5, -5);
            ctx.lineTo(-5, 5);
            ctx.closePath();
            ctx.fillStyle = this.config.color;
            ctx.fill();
        }

        ctx.restore();
    }
    drawTombstone(ctx) { ctx.save(); ctx.translate(this.position.x, this.position.y); ctx.strokeStyle = '#666'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-6, -6); ctx.lineTo(6, 6); ctx.moveTo(6, -6); ctx.lineTo(-6, 6); ctx.stroke(); ctx.restore(); }
}

// --- Predator 类 ---
class Predator extends Agent {
    constructor(x, y, config) { super(x, y, config); }
    applyBehaviors(allBoids, otherPredators, whirlpools, volcanoes) {
        if (!this.isAlive) return;
        let attackers = [];
        for (let boid of allBoids) { if (Vector.dist(this.position, boid.position) < this.config.perceptionRadius) { let toPredator = Vector.sub(this.position, boid.position).normalize(); let boidDir = boid.velocity.mag() > 0 ? new Vector(boid.velocity.x, boid.velocity.y).normalize() : new Vector(); if (Vector.dot(toPredator, boidDir) > 0.8) { attackers.push(boid); } } }
        if (attackers.length > this.config.intimidationThreshold) { this.acceleration.add(this.flee(attackers).mult(this.config.fleeWeight)); } else { this.acceleration.add(this.seek(allBoids).mult(this.config.seekWeight)); }
        this.acceleration.add(this.separation(otherPredators).mult(this.config.separationWeight));
        this.acceleration.add(this.avoid(volcanoes).mult(4.0));
        this.applyWhirlpoolForce(whirlpools);
    }
    avoid(obstacles) { let s = new Vector(); for (let o of obstacles) { let d=Vector.dist(this.position,o.position); if (d < (o.lethalRadius || 0) + 80) { let diff = Vector.sub(this.position,o.position); diff.div(d*d); s.add(diff);}} if (s.mag()>0) { s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce*4); } return s; }
    flee(threats) { let s = new Vector(); let t=0; for (let p of threats) { s.add(Vector.sub(this.position,p.position)); t++; } if (t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce*2); } return s; }
    seek(prey) { let closestDist = Infinity; let closestPrey = null; for (let b of prey) { if (b.isAlive && Vector.dist(this.position, b.position) < this.config.perceptionRadius) { let d = Vector.dist(this.position, b.position); if (d < closestDist) { closestDist = d; closestPrey = b; } } } if (closestPrey) { let d = Vector.sub(closestPrey.position, this.position); d.normalize().mult(this.config.maxSpeed); return Vector.sub(d, this.velocity).limit(this.config.maxForce); } return new Vector(); }
    separation(otherPredators) { let s = new Vector(); let t=0; for (let o of otherPredators) { let d=Vector.dist(this.position,o.position); if (o!==this && d < this.config.separationRadius) { let diff=Vector.sub(this.position,o.position); diff.div(d); s.add(diff); t++;}} if(t>0) { s.div(t); s.normalize().mult(this.config.maxSpeed); s.sub(this.velocity).limit(this.config.maxForce); } return s; }
    draw(ctx) {
        if(!this.isAlive) return;
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(Math.atan2(this.velocity.y, this.velocity.x));

        if (this.config.image && this.config.image.complete && this.config.image.naturalWidth !== 0) {
            const imgWidth = 35;
            const imgHeight = 35;
            ctx.drawImage(this.config.image, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
        } else {
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-7, -7);
            ctx.lineTo(-7, 7);
            ctx.closePath();
            ctx.fillStyle = this.config.color;
            ctx.fill();
        }

        ctx.restore();
    }
}

// --- 背景鱼类 ---
class BackgroundFish extends Agent {
    constructor(x, y, config) { super(x, y, config); this.wanderAngle = Math.random() * Math.PI * 2; }
    update(whirlpools, volcanoes) {
        this.wanderAngle += (Math.random() - 0.5) * 0.3;
        const wanderForce = new Vector(Math.cos(this.wanderAngle), Math.sin(this.wanderAngle));
        wanderForce.mult(0.05); this.acceleration.add(wanderForce);
        
        let avoidForce = new Vector();
        for(const v of volcanoes) {
            const dist = Vector.dist(this.position, v.position);
            if (dist < v.lethalRadius + 50) {
                let diff = Vector.sub(this.position, v.position);
                diff.div(dist * dist);
                avoidForce.add(diff);
            }
        }
        if (avoidForce.mag() > 0) {
            avoidForce.normalize().mult(this.config.maxSpeed);
            avoidForce.sub(this.velocity).limit(this.config.maxForce * 5);
            this.acceleration.add(avoidForce);
        }

        this.applyWhirlpoolForce(whirlpools);
        super.update();
    }
    draw(ctx) { ctx.save(); ctx.translate(this.position.x, this.position.y); ctx.rotate(Math.atan2(this.velocity.y, this.velocity.x)); ctx.beginPath(); ctx.ellipse(0, 0, 4, 2, 0, 0, Math.PI * 2); ctx.fillStyle = this.config.color; ctx.fill(); ctx.restore(); }
}

// --- 水龙卷类 ---
class Whirlpool {
    constructor(x, y) {
        this.position = new Vector(x, y);
        this.velocity = new Vector(Math.random() - 0.5, Math.random() - 0.5).mult(2.2); 
        this.creationTime = Date.now();
        this.isAlive = true;
        
        const totalLife = 12000 + Math.random() * 8000;
        this.growDuration = totalLife * 0.25;
        this.shrinkDuration = totalLife * 0.35;
        this.endTime = this.creationTime + totalLife;

        this.baseRadius = 250 + Math.random() * 100;
        this.baseStrength = 0.4 + Math.random() * 0.2;
        this.lifeCycleProgress = 0;
    }
    update() {
        const now = Date.now();
        if (now > this.endTime) { this.isAlive = false; return; }

        const age = now - this.creationTime;
        const timeUntilEnd = this.endTime - now;

        if (age < this.growDuration) {
            this.lifeCycleProgress = age / this.growDuration;
        } else if (timeUntilEnd < this.shrinkDuration) {
            this.lifeCycleProgress = timeUntilEnd / this.shrinkDuration;
        } else {
            this.lifeCycleProgress = 1.0;
        }
        
        this.position.add(this.velocity);
        this.edges();
    }
    edges() {
        const radius = this.baseRadius * this.lifeCycleProgress;
        if (this.position.x > window.innerWidth + radius) this.position.x = -radius;
        else if (this.position.x < -radius) this.position.x = window.innerWidth + radius;
        if (this.position.y > window.innerHeight + radius) this.position.y = -radius;
        else if (this.position.y < -radius) this.position.y = window.innerHeight + radius;
    }
}

// --- 海底火山类 ---
class Volcano {
    constructor(x, y) {
        this.position = new Vector(x, y);
        this.creationTime = Date.now();
        this.isAlive = true;

        const totalLife = 11000 + Math.random() * 7000;
        this.fissureDuration = totalLife * 0.25;
        this.lavaDuration = totalLife * 0.5;
        this.coolDuration = totalLife * 0.25;
        this.endTime = this.creationTime + totalLife;

        this.maxLethalRadius = 50 + Math.random() * 20;
        this.lethalRadius = 0;
        
        this.fissureLength = 300 + Math.random() * 100;
        this.influenceRadius = 150;
        this.displacementStrength = 0;
        this.heatStrength = 0;

        this.angle = (Math.random() - 0.5) * Math.PI * 0.8;
        
        this.particles = [];
         for(let i=0; i<50; i++) {
            this.particles.push({
                pos: this.position.clone(),
                vel: new Vector(Math.random() * 2 - 1, -Math.random() * 3),
                life: Math.random(),
                size: Math.random() * 2.5 + 1
            });
        }
    }

    update() {
        const now = Date.now();
        if (now > this.endTime) {
            this.isAlive = false;
            return;
        }
        const age = now - this.creationTime;
        
        let progress;
        if (age < this.fissureDuration) {
            progress = age / this.fissureDuration;
            this.lethalRadius = 0;
            this.displacementStrength = 25 * progress;
            this.heatStrength = progress;
        } else if (age < this.fissureDuration + this.lavaDuration) {
            progress = (age - this.fissureDuration) / this.lavaDuration;
            const pulse = progress < 0.8 ? (progress / 0.8) : 1;
            this.lethalRadius = this.maxLethalRadius * pulse;
            this.displacementStrength = 25 + 35 * pulse;
            this.heatStrength = 1.0;
        } else {
            progress = (age - this.fissureDuration - this.lavaDuration) / this.coolDuration;
            this.lethalRadius = this.maxLethalRadius * (1 - progress);
            this.displacementStrength = 60 * (1 - progress);
            this.heatStrength = 1 - progress;
        }

        this.particles.forEach(p => {
            p.pos.add(p.vel);
            p.vel.y += 0.03;
            p.life -= 0.015;
            if(p.life <= 0) {
                const randomPosOnFissure = new Vector( (Math.random() - 0.5) * this.fissureLength, 0);
                const rotatedPos = new Vector(
                    randomPosOnFissure.x * Math.cos(this.angle) - randomPosOnFissure.y * Math.sin(this.angle),
                    randomPosOnFissure.x * Math.sin(this.angle) + randomPosOnFissure.y * Math.cos(this.angle)
                );
                p.pos = this.position.clone().add(rotatedPos);
                p.vel = new Vector(Math.random() * 1 - 0.5, -Math.random() * 2.5 * this.heatStrength);
                p.life = Math.random() * 0.5 + 0.5;
            }
        });
    }

    draw(ctx) {
        if (!this.isAlive) return;
        ctx.save();
        this.particles.forEach(p => {
            if (p.life > 0) {
                 const heat = this.heatStrength;
                 const alpha = p.life * 0.6 * heat;
                 ctx.fillStyle = `rgba(255, ${150 * heat}, 0, ${alpha})`;
                 ctx.beginPath();
                 ctx.arc(p.pos.x, p.pos.y, p.size, 0, Math.PI * 2);
                 ctx.fill();
            }
        });
        ctx.restore();
    }
}


// --- 主程序 ---
const canvas = document.getElementById('boidsCanvas'), ctx = canvas.getContext('2d');
canvas.width = window.innerWidth; canvas.height = window.innerHeight;
let mouseTarget = null, targetTimeout = null;
const MOUSE_INFLUENCE_RADIUS = 250;
let clickWaves = [], animationTime = 0, audioInitialized = false;

let whirlpools = [];
const MAX_WHIRLPOOLS = 1;
const WHIRLPOOL_SPAWN_CHANCE = 0.002;

let volcanoes = [];
const MAX_VOLCANOES = 1;
const VOLCANO_SPAWN_CHANCE = 0.0015;

// --- 音频对象 ---
const soundA = new Audio('sound/a.mp3'), soundB = new Audio('sound/b.mp3'), soundC = new Audio('sound/c.mp3');
const birthSoundA = new Audio('sound/a.mp3'), birthSoundB = new Audio('sound/b.mp3'), birthSoundC = new Audio('sound/c.mp3');
const ambienceSoundA = new Audio('sound/a.mp3'), ambienceSoundB = new Audio('sound/b.mp3'), ambienceSoundC = new Audio('sound/c.mp3');
const ambienceSounds = [ambienceSoundA, ambienceSoundB, ambienceSoundC];
[soundA, soundB, soundC, birthSoundA, birthSoundB, birthSoundC].forEach(s => s.volume = 0);
ambienceSounds.forEach(s => { s.volume = 0; s.loop = true; });

// --- 音量控制 ---
const MIN_GLOBAL_VOLUME = 0.15, MAX_GLOBAL_VOLUME = 1.0, BOIDS_FOR_MAX_VOLUME = 30;
const MIN_BIRTH_VOLUME = 0.05, MAX_BIRTH_VOLUME = 0.4, BABIES_FOR_MAX_BIRTH_VOLUME = 5;
const MEETING_RADIUS = 70, MIN_BOIDS_FOR_MEETING = 10, MAX_INTERACTION_VOLUME = 0.35, BOIDS_FOR_MAX_INTERACTION_VOLUME = 50;

// --- 配置区域 ---
const reproductionConfig = { canReproduce: true, reproductionRadius: 20, reproductionThreshold: 3, reproductionUrgeMax: 100, reproductionChance: 0.05 };
const flockA_Config = { image: imageA, color: '#4f8a8b', maxSpeed: 3.5, maxForce: 0.05, perceptionRadius: 50, separationRadius: 25, fleeRadius: 100, avoidRadius: 50, cohesionWeight: 1.0, alignmentWeight: 1.0, separationWeight: 1.5, fleeWeight: 2.5, seekWeight: 1.2, avoidWeight: 3.5, canMob: false, ...reproductionConfig };
const flockB_Config = { image: imageB, color: '#ffcb74', maxSpeed: 4.0, maxForce: 0.07, perceptionRadius: 60, separationRadius: 30, fleeRadius: 120, avoidRadius: 60, cohesionWeight: 0.8, alignmentWeight: 1.2, separationWeight: 1.3, fleeWeight: 2.0, seekWeight: 1.0, avoidWeight: 3.3, canMob: false, ...reproductionConfig };
const flockC_Config = { image: imageC, color: '#a374ff', maxSpeed: 3.8, maxForce: 0.06, perceptionRadius: 70, separationRadius: 28, fleeRadius: 110, avoidRadius: 55, cohesionWeight: 1.2, alignmentWeight: 0.8, separationWeight: 1.4, fleeWeight: 1.8, seekWeight: 1.1, avoidWeight: 3.4, canMob: true, mobThreshold: 5, mobWeight: 2.5, ...reproductionConfig };
const predatorConfig = { image: imagePredator, color: '#f07167', maxSpeed: 4.5, maxForce: 0.12, perceptionRadius: 200, separationRadius: 50, killRadius: 8, seekWeight: 1.8, separationWeight: 2.0, intimidationThreshold: 6, fleeWeight: 3.0 };
const NUM_BACKGROUND_FISH = 25, BACKGROUND_FISH_COLORS = ['#3a506b', '#5c6e81', '#1c2541', '#0b132b'], backgroundFishConfig = { maxSpeed: 1, maxForce: 0.03 };

// --- 初始化 ---
const NUM_BOIDS_PER_FLOCK = 70;
let flockA = [], flockB = [], flockC = [], allBoids = [], predators = [], tombstones = [], backgroundFish = [];
let initialCountA = 0, initialCountB = 0, initialCountC = 0;
const w = () => canvas.width, h = () => canvas.height;
const percentAEl = document.getElementById('percentA'), percentBEl = document.getElementById('percentB'), percentCEl = document.getElementById('percentC');

function initialize() {
    flockA = []; flockB = []; flockC = []; allBoids = []; predators = []; tombstones = []; backgroundFish = []; whirlpools = []; volcanoes = [];
    for (let i = 0; i < NUM_BOIDS_PER_FLOCK; i++) { const b = new Boid(Math.random()*w(), Math.random()*h(), flockA_Config); flockA.push(b); allBoids.push(b); }
    for (let i = 0; i < NUM_BOIDS_PER_FLOCK; i++) { const b = new Boid(Math.random()*w(), Math.random()*h(), flockB_Config); flockB.push(b); allBoids.push(b); }
    for (let i = 0; i < NUM_BOIDS_PER_FLOCK; i++) { const b = new Boid(Math.random()*w(), Math.random()*h(), flockC_Config); flockC.push(b); allBoids.push(b); }
    for (let i = 0; i < 4; i++) { predators.push(new Predator(Math.random()*w(), Math.random()*h(), predatorConfig)); }
    for (let i = 0; i < NUM_BACKGROUND_FISH; i++) { const color = BACKGROUND_FISH_COLORS[Math.floor(Math.random() * BACKGROUND_FISH_COLORS.length)]; backgroundFish.push(new BackgroundFish(Math.random() * w(), Math.random() * h(), { ...backgroundFishConfig, color: color })); }
    initialCountA = flockA.length; initialCountB = flockB.length; initialCountC = flockC.length;
}

// --- 背景绘制函数 ---
function drawBackgroundEffect(ctx, time, whirlpools, volcanoes) {
    const gridSpacing = 60;
    const waveAmplitude = 2.5;
    const waveFrequency = 0.04;
    const heatColor = [255, 120, 0];
    const defaultGridColor = [60, 80, 100];

    const lerp = (a, b, t) => a + (b - a) * t;

    function getDistortionData(x, y) {
        let finalPoint = new Vector(x, y);
        let heat = 0;

        for(const w of whirlpools) {
            const currentRadius = w.baseRadius * w.lifeCycleProgress;
            const toPoint = Vector.sub(finalPoint, w.position);
            const dist = toPoint.mag();

            if (dist > 0 && dist < currentRadius) {
                const progress = dist / currentRadius;
                const swirlAngle = (1 - progress) * w.baseStrength * 2.5 * w.lifeCycleProgress;
                const pinchAmount = dist * (1 - progress) * 0.2;
                
                const angle = Math.atan2(toPoint.y, toPoint.x);
                const finalAngle = angle + swirlAngle;
                const finalDist = dist - pinchAmount;
                finalPoint.x = w.position.x + Math.cos(finalAngle) * finalDist;
                finalPoint.y = w.position.y + Math.sin(finalAngle) * finalDist;
            }
        }
        
        for(const v of volcanoes) {
             const toPoint = Vector.sub(finalPoint, v.position);
             const distToCenter = toPoint.mag();

             if (distToCenter < v.influenceRadius + v.fissureLength / 2) {
                const cosA = Math.cos(-v.angle);
                const sinA = Math.sin(-v.angle);
                const localX = toPoint.x * cosA - toPoint.y * sinA;
                const localY = toPoint.x * sinA + toPoint.y * cosA;

                if (Math.abs(localX) < v.fissureLength / 2 && Math.abs(localY) < v.influenceRadius) {
                    const falloff = 1 - Math.abs(localY) / v.influenceRadius;
                    const displacement = v.displacementStrength * falloff * Math.sign(localY);
                    
                    const worldDispX = 0 * cosA - displacement * sinA;
                    const worldDispY = 0 * sinA + displacement * cosA;
                    finalPoint.x -= worldDispX;
                    finalPoint.y -= worldDispY;

                    heat = Math.max(heat, v.heatStrength * falloff);
                }
             }
        }
        return { point: finalPoint, heat: heat };
    }
    
    ctx.save();
    ctx.lineWidth = 0.85;

    for (let x = 0; x < w() + gridSpacing; x += gridSpacing) {
        ctx.beginPath();
        for (let y = 0; y < h(); y++) {
            const offsetX = Math.sin(y * waveFrequency + time) * waveAmplitude;
            const data = getDistortionData(x + offsetX, y);
            
            const r = lerp(defaultGridColor[0], heatColor[0], data.heat);
            const g = lerp(defaultGridColor[1], heatColor[1], data.heat);
            const b = lerp(defaultGridColor[2], heatColor[2], data.heat);
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;

            (y === 0) ? ctx.moveTo(data.point.x, data.point.y) : ctx.lineTo(data.point.x, data.point.y);
        }
        ctx.stroke();
    }
    
    for (let y = 0; y < h() + gridSpacing; y += gridSpacing) {
        ctx.beginPath();
        for (let x = 0; x < w(); x++) {
            const offsetY = Math.sin(x * waveFrequency + time) * waveAmplitude;
            const data = getDistortionData(x, y + offsetY);
            
            const r = lerp(defaultGridColor[0], heatColor[0], data.heat);
            const g = lerp(defaultGridColor[1], heatColor[1], data.heat);
            const b = lerp(defaultGridColor[2], heatColor[2], data.heat);
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;

            (x === 0) ? ctx.moveTo(data.point.x, data.point.y) : ctx.lineTo(data.point.x, data.point.y);
        }
        ctx.stroke();
    }
    ctx.restore();
}

// --- 动画循环 ---
function animate() {
    if (imageBackground.complete && imageBackground.naturalWidth !== 0) {
        ctx.drawImage(imageBackground, 0, 0, w(), h());
    } else {
        ctx.fillStyle = 'rgb(13, 17, 23)';
        ctx.fillRect(0, 0, w(), h());
    }

    animationTime += 0.02;
    
    if (Math.random() < WHIRLPOOL_SPAWN_CHANCE && whirlpools.length < MAX_WHIRLPOOLS) { whirlpools.push(new Whirlpool(Math.random() * w(), Math.random() * h())); }
    whirlpools.forEach(w => w.update());
    whirlpools = whirlpools.filter(w => w.isAlive);
    
    if (Math.random() < VOLCANO_SPAWN_CHANCE && volcanoes.length < MAX_VOLCANOES) { volcanoes.push(new Volcano(Math.random() * w(), Math.random() * h())); }
    volcanoes.forEach(v => v.update());
    
    drawBackgroundEffect(ctx, animationTime, whirlpools, volcanoes);

    volcanoes.forEach(v => v.draw(ctx));
    volcanoes = volcanoes.filter(v => v.isAlive);

    const now = Date.now();
    for (let i = clickWaves.length - 1; i >= 0; i--) { const wave = clickWaves[i]; const age = now - wave.startTime; if (age > wave.duration) { clickWaves.splice(i, 1); continue; } const progress = age / wave.duration; ctx.beginPath(); ctx.arc(wave.position.x, wave.position.y, wave.maxRadius * progress, 0, Math.PI * 2); ctx.strokeStyle = `rgba(88, 166, 255, ${1 - progress})`; ctx.lineWidth = 2; ctx.stroke(); }
    
    backgroundFish.forEach(fish => { fish.update(whirlpools, volcanoes); fish.edges(); fish.draw(ctx); });

    let newborns = [], newbornCountA=0, newbornCountB=0, newbornCountC=0;
    allBoids.forEach(boid => { let ownFlock = (boid.config.color === flockA_Config.color) ? flockA : (boid.config.color === flockB_Config.color) ? flockB : flockC; boid.applyBehaviors(allBoids, ownFlock, predators, tombstones, mouseTarget, whirlpools, volcanoes); boid.update(); boid.edges(); boid.draw(ctx); const newborn = boid.handleReproduction(ownFlock); if (newborn) { newborns.push(newborn); } });
    
    newborns.forEach(nb => { allBoids.push(nb); if (nb.config.color === flockA_Config.color) { flockA.push(nb); initialCountA++; newbornCountA++; } else if (nb.config.color === flockB_Config.color) { flockB.push(nb); initialCountB++; newbornCountB++; } else { flockC.push(nb); initialCountC++; newbornCountC++; } });
    const playBirthSound = (sound, count) => { if (count > 0 && audioInitialized) { const v = MIN_BIRTH_VOLUME + Math.min(1, count / BABIES_FOR_MAX_BIRTH_VOLUME) * (MAX_BIRTH_VOLUME - MIN_BIRTH_VOLUME); sound.volume = v; sound.currentTime = 0; sound.play().catch(e => {}); } };
    playBirthSound(birthSoundA, newbornCountA); playBirthSound(birthSoundB, newbornCountB); playBirthSound(birthSoundC, newbornCountC);

    predators.forEach(predator => { predator.applyBehaviors(allBoids, predators, whirlpools, volcanoes); predator.update(); predator.edges(); predator.draw(ctx); for (let i = allBoids.length - 1; i >= 0; i--) { const boid = allBoids[i]; if (boid.isAlive && Vector.dist(predator.position, boid.position) < predator.config.killRadius) { boid.isAlive = false; boid.deathTime = Date.now(); tombstones.push(boid); allBoids.splice(i, 1); } } });
    
    // *** FIX START: 改变火山杀伤逻辑，从半径检测改为粒子碰撞检测 ***
    for (const v of volcanoes) {
        // 只有在火山活跃喷发期（热度高）时，其粒子才具有杀伤力
        if (v.heatStrength > 0.5) { 
            for (const p of v.particles) {
                // 粒子必须是存活状态
                if (p.life > 0) {
                    // 检查 Boids
                    for (let i = allBoids.length - 1; i >= 0; i--) {
                        const boid = allBoids[i];
                        // 碰撞检测：智能体与粒子的距离 < 粒子半径 + 智能体大致半径
                        if (boid.isAlive && Vector.dist(boid.position, p.pos) < p.size + 8) { // Boid 大致半径为 8
                            boid.isAlive = false;
                            boid.deathTime = Date.now();
                            tombstones.push(boid);
                            allBoids.splice(i, 1);
                        }
                    }
                    // 检查捕食者
                    for (let i = predators.length - 1; i >= 0; i--) {
                        const pred = predators[i];
                        if (pred.isAlive && Vector.dist(pred.position, p.pos) < p.size + 12) { // 捕食者体型更大，半径约 12
                            pred.isAlive = false;
                            predators.splice(i, 1);
                        }
                    }
                    // 检查背景鱼
                    for (let i = backgroundFish.length - 1; i >= 0; i--) {
                        const fish = backgroundFish[i];
                        if (fish.isAlive && Vector.dist(fish.position, p.pos) < p.size + 4) { // 背景鱼体型小，半径约 4
                            fish.isAlive = false;
                            backgroundFish.splice(i, 1);
                        }
                    }
                }
            }
        }
    }
    // *** FIX END ***

    flockA = flockA.filter(b => b.isAlive); flockB = flockB.filter(b => b.isAlive); flockC = flockC.filter(b => b.isAlive);
    tombstones.forEach(t => t.draw(ctx)); tombstones = tombstones.filter(t => Date.now() - t.deathTime < 3000);

    let targetAmbience = { a: 0, b: 0, c: 0 };
    const interactionPairs = [ { f1: flockA, f2: flockB, k1: 'a', k2: 'b' }, { f1: flockA, f2: flockC, k1: 'a', k2: 'c' }, { f1: flockB, f2: flockC, k1: 'b', k2: 'c' } ];
    for (const pair of interactionPairs) {
        if (pair.f1.length < MIN_BOIDS_FOR_MEETING || pair.f2.length < MIN_BOIDS_FOR_MEETING) continue;
        const nearBoids1 = [], nearBoids2 = new Set();
        for (const b1 of pair.f1) { let isNear = false; for (const b2 of pair.f2) { if (Vector.dist(b1.position, b2.position) < MEETING_RADIUS) { isNear = true; nearBoids2.add(b2); } } if (isNear) { nearBoids1.push(b1); } }
        if (nearBoids1.length >= MIN_BOIDS_FOR_MEETING && nearBoids2.size >= MIN_BOIDS_FOR_MEETING) {
            const avgVel1 = new Vector(); nearBoids1.forEach(b => avgVel1.add(b.velocity)); avgVel1.div(nearBoids1.length);
            const avgVel2 = new Vector(); nearBoids2.forEach(b => avgVel2.add(b.velocity)); avgVel2.div(nearBoids2.size);
            if (avgVel1.mag() > 0 && avgVel2.mag() > 0) { const dot = Vector.dot(avgVel1.normalize(), avgVel2.normalize()); if (dot < 0) { const v = (nearBoids1.length + nearBoids2.size) / BOIDS_FOR_MAX_INTERACTION_VOLUME * MAX_INTERACTION_VOLUME; targetAmbience[pair.k1] += v * -dot; targetAmbience[pair.k2] += v * -dot; } }
        }
    }
    const ease = 0.05;
    ambienceSoundA.volume += (Math.min(targetAmbience.a, MAX_INTERACTION_VOLUME) - ambienceSoundA.volume) * ease;
    ambienceSoundB.volume += (Math.min(targetAmbience.b, MAX_INTERACTION_VOLUME) - ambienceSoundB.volume) * ease;
    ambienceSoundC.volume += (Math.min(targetAmbience.c, MAX_INTERACTION_VOLUME) - ambienceSoundC.volume) * ease;

    if (initialCountA > 0) percentAEl.innerText = `${Math.round((flockA.length / NUM_BOIDS_PER_FLOCK) * 100)}%`;
    if (initialCountB > 0) percentBEl.innerText = `${Math.round((flockB.length / NUM_BOIDS_PER_FLOCK) * 100)}%`;
    if (initialCountC > 0) percentCEl.innerText = `${Math.round((flockC.length / NUM_BOIDS_PER_FLOCK) * 100)}%`;

    requestAnimationFrame(animate);
}

// --- 事件监听器 ---
canvas.addEventListener('mousedown', e => { 
    if (!audioInitialized) { ambienceSounds.forEach(s => s.play().catch(e => {})); audioInitialized = true; }
    mouseTarget = new Vector(e.clientX, e.clientY); 
    if(targetTimeout) clearTimeout(targetTimeout); 
    targetTimeout = setTimeout(()=> {mouseTarget = null;}, 5000); 
    clickWaves.push({ position: new Vector(e.clientX, e.clientY), startTime: Date.now(), duration: 800, maxRadius: 60, });
    let awareCounts = { a: 0, b: 0, c: 0 };
    allBoids.forEach(boid => { if (boid.isAlive && Vector.dist(boid.position, mouseTarget) < MOUSE_INFLUENCE_RADIUS) { boid.showAwarenessIndicator(); if (boid.config.color === flockA_Config.color) awareCounts.a++; else if (boid.config.color === flockB_Config.color) awareCounts.b++; else awareCounts.c++; } });
    const totalAware = awareCounts.a + awareCounts.b + awareCounts.c;
    if (totalAware > 0) {
        const masterVolume = MIN_GLOBAL_VOLUME + Math.min(1, totalAware / BOIDS_FOR_MAX_VOLUME) * (MAX_GLOBAL_VOLUME - MIN_GLOBAL_VOLUME);
        const playSound = (audio, vol) => { if (vol > 0.01) { audio.volume = vol; audio.currentTime = 0; audio.play().catch(e => {}); } };
        playSound(soundA, masterVolume * (awareCounts.a / totalAware));
        playSound(soundB, masterVolume * (awareCounts.b / totalAware));
        playSound(soundC, masterVolume * (awareCounts.c / totalAware));
    }
});
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; initialize(); });

// 启动
initialize();
animate();
</script>
</body>
</html>
